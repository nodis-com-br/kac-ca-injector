/*
 * Kubernetes Admission Controller
 *
 * This is a generic definition for a Kubernetes Admission Controller
 *
 * API version: 1.0.0
 * Contact: infra@nodis.com.br
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package kac

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"

	admissionv1 "k8s.io/api/admission/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/wI2L/jsondiff"
)

const (
	keyCABundleURL        = "CA_BUNDLE_URL"
	keyConfigMapName      = "CA_BUNDLE_CONFIGMAP"
	keyCABundleFilename   = "CA_BUNDLE_FILENAME"
	keyCABundleAnnotation = "CA_BUNDLE_ANNOTATION"
	keyPodNamespace       = "POD_NAMESPACE"
)

var (
	podsGVR = metav1.GroupVersionResource{Version: "v1", Resource: "pods"}
	podGVK  = schema.GroupVersionKind{Version: "v1", Kind: "Pod"}
)

func validationReviewer(ctx context.Context, ar admissionv1.AdmissionReview) (*admissionv1.AdmissionResponse, error) {

	pt := admissionv1.PatchTypeJSONPatch
	return &admissionv1.AdmissionResponse{Allowed: true, PatchType: &pt, Patch: []byte{}}, nil

}

func mutationReviewer(ctx context.Context, ar admissionv1.AdmissionReview) (*admissionv1.AdmissionResponse, error) {

	configMapName := os.Getenv(keyConfigMapName)
	caBundleFilename := os.Getenv(keyCABundleFilename)
	caBundleAnnotation := os.Getenv(keyCABundleAnnotation)
	caBundleURL := os.Getenv(keyCABundleURL)
	currentNamespace := os.Getenv(keyPodNamespace)

	// Deserialize and copy request object
	obj, err := validateAndDeserialize(ar, podsGVR, podGVK)
	if err != nil {
		return nil, err
	}
	pod := obj.(*corev1.Pod)
	newPod := pod.DeepCopy()

	// Inject ca bundle configmap if pods contains annotation
	if pod.Annotations[caBundleAnnotation] == "true" {

		// If the pod is in the same namespace as the webhook, the namespace
		// will be empty and must be manually set
		namespace := pod.Namespace
		if namespace == "" {
			namespace = currentNamespace
		}

		// Connect to to kubernetes cluster to check if configmap exists
		clientSet, err := getKubernetesClientSet(ctx)
		if err != nil {
			return nil, err
		}
		configMap, _ := clientSet.CoreV1().ConfigMaps(fmt.Sprint(namespace)).Get(ctx, configMapName, metav1.GetOptions{})

		// Create configmap if not found
		if configMap == nil || configMap.Name == "" {
			resp, err := http.Get(caBundleURL)
			if err != nil {
				return nil, err
			}
			body, _ := ioutil.ReadAll(resp.Body)
			defer func() { _ = resp.Body.Close() }()
			if !strings.Contains(string(body), "-----BEGIN CERTIFICATE-----") {
				return nil, fmt.Errorf("invalid ca bundle")
			}
			if configMap, err = clientSet.CoreV1().ConfigMaps(namespace).Create(ctx, &corev1.ConfigMap{
				TypeMeta: metav1.TypeMeta{},
				ObjectMeta: metav1.ObjectMeta{
					Name:      configMapName,
					Namespace: namespace,
				},
				Data: map[string]string{
					caBundleFilename: string(body),
				},
			}, metav1.CreateOptions{}); err != nil {
				return nil, err
			}
		}

		// Add Volume to new pod
		newPod.Spec.Volumes = append(newPod.Spec.Volumes, corev1.Volume{
			Name: configMap.Name,
			VolumeSource: corev1.VolumeSource{
				ConfigMap: &corev1.ConfigMapVolumeSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: configMap.Name,
					},
				},
			},
		})

		// Add VolumeMounts to new pod containers
		for i := range newPod.Spec.Containers {
			newPod.Spec.Containers[i].VolumeMounts = append(newPod.Spec.Containers[i].VolumeMounts, corev1.VolumeMount{
				Name:      configMap.Name,
				MountPath: "/etc/ssl/certs/" + caBundleFilename,
				SubPath:   caBundleFilename,
			})
		}

	}

	// Create mutation patch
	patch, _ := jsondiff.Compare(pod, newPod)
	encodedPatch, _ := json.Marshal(patch)

	// Return AdmissionReview object with AdmissionResponse
	pt := admissionv1.PatchTypeJSONPatch
	return &admissionv1.AdmissionResponse{Allowed: true, PatchType: &pt, Patch: encodedPatch}, nil

}
